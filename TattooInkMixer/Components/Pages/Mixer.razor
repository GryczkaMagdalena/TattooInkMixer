@page "/"
@page "/mixer"
@rendermode InteractiveServer
@using TattooInkMixer.Services

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6" GutterBottom="true">Requested color</MudText>

    <div class="color-editor requested-color-editor">
        <label class="color-swatch" style="@GetColorPreviewStyle(TargetHex)">
            <input type="color" value="@GetColorInputValue(TargetHex)" @oninput="@(e => UpdateTargetFromPicker(e.Value?.ToString()))" />
        </label>

        <MudTextField T="string"
                      Label="HEX"
                      Value="@TargetHex"
                      ValueChanged="UpdateTargetFromHex"
                      Immediate="true"
                      Variant="Variant.Outlined"
                      Margin="Margin.Dense" />

        <MudTextField T="string"
                      Label="RGB"
                      Value="@HexToRgbText(TargetHex)"
                      ValueChanged="UpdateTargetFromRgb"
                      Immediate="true"
                      Variant="Variant.Outlined"
                      Margin="Margin.Dense" />
    </div>

    <MudNumericField T="int" Label="Max inks to use" Variant="Variant.Outlined" Min="1" Max="20" Class="mt-4" @bind-Value="MaxInks" />

    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="Solve" Class="mt-4">Mix</MudButton>

    @if (!string.IsNullOrWhiteSpace(Error))
    {
        <MudAlert Severity="Severity.Error" Dense="true" Class="mt-3">@Error</MudAlert>
    }

    @if (Result is not null)
    {
        <MudText Typo="Typo.h6" Class="mt-4">Recipe</MudText>

        <MudTable Items="@GetRecipeRows()" Dense="true" Hover="true" Bordered="true" Striped="true" Class="mt-2">
            <HeaderContent>
                <MudTh>Color</MudTh>
                <MudTh>Percentage</MudTh>
                <MudTh>Drops (1.5 ml)</MudTh>
                <MudTh>Drops (3 ml)</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.Name (@context.Hex)</MudTd>
                <MudTd><b>@context.PercentageText</b></MudTd>
                <MudTd>@context.DropsFor15Ml</MudTd>
                <MudTd>@context.DropsFor3Ml</MudTd>
            </RowTemplate>
        </MudTable>

        <MudDivider Class="my-4" />
        <MudText>
            Predicted mix: <b>@Result.PredictedHex</b>
        </MudText>
        <div class="mt-2" style="@GetColorPreviewStyle(Result.PredictedHex)"></div>
        <MudText Class="mt-2" Style="@GetSimilarityTextStyle(Result.ErrorRmse)">Similarity: @GetSimilarityText(Result.ErrorRmse)</MudText>
    }
</MudPaper>

@code {
    private string TargetHex = "#FF8800";
    private int MaxInks = 4;
    private string? Error;
    private InkMixResult? Result;

    [Inject] private ColorTableStore ColorTableStore { get; set; } = default!;

    protected override void OnInitialized()
    {
        ColorTableStore.EnsureInitialized();
    }

    private static string GetColorPreviewStyle(string hex) => $"background:{hex}; width:48px; height:28px; border:1px solid #999; border-radius:4px;";

    private static int DropsPerMilliliter => 20;

    private IEnumerable<RecipeRow> GetRecipeRows()
    {
        if (Result is null)
            return Enumerable.Empty<RecipeRow>();

        return GetSolveCandidates().Zip(Result.Weights)
            .Where(pair => pair.Second > 1e-6)
            .Select(pair => new RecipeRow(
                pair.First.DisplayName,
                pair.First.Hex,
                $"{(pair.Second * 100):0.00}%",
                CalculateDrops(pair.Second, 1.5),
                CalculateDrops(pair.Second, 3.0)));
    }

    private IEnumerable<SolveInkCandidate> GetSolveCandidates()
    {
        var entries = ColorTableStore.Entries;
        var userInks = entries
            .Where(entry => string.Equals(entry.Category, ColorCategory.Standard, StringComparison.OrdinalIgnoreCase))
            .Select(entry => new SolveInkCandidate(entry.Name, entry.Hex));

        var marketInks = entries
            .Where(entry => string.Equals(entry.Category, ColorCategory.Company, StringComparison.OrdinalIgnoreCase))
            .Select(entry => new SolveInkCandidate($"{entry.Brand ?? string.Empty} - {entry.Name}", entry.Hex));

        return userInks.Concat(marketInks);
    }

    private static string GetSimilarityText(double rmse)
    {
        var similarity = Math.Clamp(1.0 - rmse, 0.0, 1.0);
        return $"{(similarity * 100):0.00}%";
    }

    private static string GetSimilarityTextStyle(double rmse)
    {
        var similarity = Math.Clamp(1.0 - rmse, 0.0, 1.0);
        if (similarity >= 0.95)
            return "color:#00C853;";

        if (similarity >= 0.90)
            return "color:#FB8C00;";

        return "color:#FF1744;";
    }

    private static int CalculateDrops(double weight, double cupSizeMl)
    {
        var totalDrops = cupSizeMl * DropsPerMilliliter;
        return (int)Math.Round(totalDrops * weight, MidpointRounding.AwayFromZero);
    }

    private static string GetColorInputValue(string hex)
    {
        try
        {
            _ = Rgb.FromHex(hex);
            return hex;
        }
        catch
        {
            return "#808080";
        }
    }

    private static string HexToRgbText(string hex)
    {
        try
        {
            var rgb = Rgb.FromHex(hex);
            return $"{rgb.R}, {rgb.G}, {rgb.B}";
        }
        catch
        {
            return string.Empty;
        }
    }

    private static string? RgbTextToHex(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return null;

        var parts = value.Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 3)
            return null;

        if (!byte.TryParse(parts[0], out var r) || !byte.TryParse(parts[1], out var g) || !byte.TryParse(parts[2], out var b))
            return null;

        return $"#{r:X2}{g:X2}{b:X2}";
    }

    private void UpdateTargetFromPicker(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            return;

        TargetHex = value.ToUpperInvariant();
        Result = null;
    }

    private void UpdateTargetFromHex(string? value)
    {
        TargetHex = string.IsNullOrWhiteSpace(value) ? string.Empty : value.Trim();
        Result = null;
    }

    private void UpdateTargetFromRgb(string? value)
    {
        var hex = RgbTextToHex(value);
        if (hex is null)
            return;

        TargetHex = hex;
        Result = null;
    }

    private void Solve()
    {
        Error = null;
        Result = null;

        try
        {
            _ = Rgb.FromHex(TargetHex);
            var solveCandidates = GetSolveCandidates().ToList();
            foreach (var ink in solveCandidates) _ = Rgb.FromHex(ink.Hex);

            var hexes = solveCandidates.Select(x => x.Hex).ToList();
            Result = InkMixSolver.SolveWithLimit(hexes, TargetHex, MaxInks);
        }
        catch (Exception ex)
        {
            Error = ex.Message;
        }
    }

    private sealed record RecipeRow(string Name, string Hex, string PercentageText, int DropsFor15Ml, int DropsFor3Ml);
    private sealed record SolveInkCandidate(string DisplayName, string Hex);
}
